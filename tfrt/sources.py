"""
Classes to help make source light raysets that can be fed to the ray tracer.



"""
import math
from abc import ABC, abstractmethod

from scipy.special import erfinv
import tensorflow as tf
import numpy as np

PI = math.pi

# =====================================================================================


class AngularDistributionBase(ABC):
    """
    Abstract implementation of an angular distribution, that defines the bare
    minimum interface that all angular distributions should implement.
        
    """

    def __init__(self, min_angle, max_angle, sample_count, name="AngularDistribution"):
        """
        Angular distribution constructors do not need to follow the pattern set by
        the constructor defined here, but most will, so this implementation is
        provided for convenience.  A constructor should not construct any tf ops, it
        should only store values for use by the class at a later time.  All angular
        distribution constructors should accept a name keyword argument, which is used
        to define a namespace in which all tf ops constructed by the class are placed.
        
        """
        self._min_angle = min_angle
        self._max_angle = max_angle
        self._sample_count = sample_count
        self._name = name

        self._angles = None
        self._ranks = None

    def _angle_limit_validation_ops(self, lower_limit, upper_limit):
        """
        Convenience for sub classes that require angle limits, to help with range 
        checking.  The return is a list of assert ops which should be listed as a
        dependency for the ops in build; use:
        
        with tf.control_dependencies(self.angle_limit_validation_ops()):
        
        """
        return [
            tf.assert_greater_equal(
                self._max_angle,
                self._min_angle,
                message=f"{self.__class__.__name__}: max_angle must be >= min_angle.",
            ),
            tf.assert_greater_equal(
                self._min_angle,
                lower_limit,
                message=f"{self.__class__.__name__}: min_angle must be >= "
                f" {lower_limit}.",
            ),
            tf.assert_less_equal(
                self._max_angle,
                upper_limit,
                message=f"{self.__class__.__name__}: max_angle must be <= "
                f" {upper_limit}.",
            ),
        ]

    def _build_ranks(self):
        """
        Convenience function for generating the angle ranks in most cases.  Must be 
        called inside build, after self._angles is built, and requires that min/max
        angles are set.  If this pattern does not work, or if you generate ranks
        in the process of building the distribution, do not use it
        
        """
        self._ranks = self._angles / tf.cast(
            tf.reduce_max(tf.abs(tf.stack([self._min_angle, self._max_angle]))),
            tf.float64,
        )

    @abstractmethod
    def build(self):
        """
        All subclasses must override this method.  This method will use the values
        stored inside the class in the constructor to build the TF ops that
        generate the distribution.  If you are going to use the angle limit
        validation, the ops in here should list those as dependencies.
        
        This method is separated from the constructor for cleanliness of the tf graph:
        It will allow the ops generated by this class to be easily colocated with the
        other ops used to build a source.
        
        The build function should overwrite self._angles which represents the angular 
        distribution built by the class.
        
        The build function may also overwrite self._ranks, if you want the subclass 
        to use angle ranks.  Otherwise this may be skipped.
        
        The ops in this function should be build within a namescope unique to the
        instance.  Use:
        
        with tf.name_scope(self._name) as scope:
        
        """
        pass

    @property
    def needs_build(self):
        if self._angles is None:
            return True
        else:
            return False

    @property
    def angles(self):
        """
        If overwritten, this should not add any ops to the tf graph.
        Should be a 1-D tensor.
        
        """
        if self._angles is None:
            raise RuntimeError(
                f"{self.__class__.__name__}: attempted to access "
                "angles before calling build."
            )
        return self._angles

    @property
    def ranks(self):
        """
        If overwritten, this should not add any ops to the tf graph.
        Should be a 1-D tensor of the same length as angles, but may also be None.
        
        """
        return self._ranks

class ManualAngleDistribution(AngularDistributionBase):
    """
    This class allows you to package a set of angles you calculated yourself into
    the format for use with a source, and does nothing except cast the inputs
    to tf.float64.  Can accept tensors or python objects.  Does no error checking.
    Inputs should be 1-D tensor-like objects, and should all have the same length.
    Ranks may be None.
    
    """
    def __init__(
        self,
        angles,
        ranks=None,
        name="ManualAngleDistribution"
    ):
        super().__init__(name=name)
        self._angles = angles
        self._ranks = ranks
        
    def build(self):
        with tf.name_scope(self._name) as scope:
            self._angles = tf.cast(self._angles, tf.float64)
            if self._ranks is not None:
                self._ranks = tf.cast(self._ranks, tf.float64)

class StaticUniformAngularDistribution(AngularDistributionBase):
    """
        For this source, rank will be normalized so that the most extreme angle
        generated by the distribution (farthest from the center of the distribution)
        will have |rank| == 1.
        
    """

    def __init__(
        self,
        min_angle,
        max_angle,
        sample_count,
        name="StaticUniformAngularDistribution",
    ):
        super().__init__(min_angle, max_angle, sample_count, name=name)

    def build(self):
        with tf.name_scope(self._name) as scope:
            with tf.control_dependencies(self._angle_limit_validation_ops(-PI, PI)):
                self._angles = tf.cast(
                    tf.linspace(self._min_angle, self._max_angle, self._sample_count),
                    tf.float64,
                )
                self._build_ranks()


class RandomUniformAngularDistribution(AngularDistributionBase):
    """
        For this source, rank will be normalized so that the most extreme angle
        generated by the distribution (farthest from the center of the distribution)
        will have |rank| == 1.
        
    """

    def __init__(
        self,
        min_angle,
        max_angle,
        sample_count,
        name="RandomUniformAngularDistribution",
    ):
        super().__init__(min_angle, max_angle, sample_count, name=name)

    def build(self):
        with tf.name_scope(self._name) as scope:
            with tf.control_dependencies(self._angle_limit_validation_ops(-PI, PI)):
                self._angles = tf.random_uniform(
                    (self._sample_count,),
                    minval=self._min_angle,
                    maxval=self._max_angle,
                    dtype=tf.float64,
                )
                self._build_ranks()


class StaticLambertianAngularDistribution(AngularDistributionBase):
    """
        For this source, rank will be the sine of the angle, so that the maximum rank
        will have magnitude sin(max(abs(angle_limits))).  Rank will be distributed 
        uniformally.
        
    """

    def __init__(
        self,
        min_angle,
        max_angle,
        sample_count,
        name="StaticLambertianAngularDistribution",
    ):
        super().__init__(min_angle, max_angle, sample_count, name=name)

    def build(self):
        with tf.name_scope(self._name) as scope:
            with tf.control_dependencies(
                self._angle_limit_validation_ops(-PI / 2.0, PI / 2.0)
            ):
                lower_rank_cutoff = tf.sin(self._min_angle)
                upper_rank_cutoff = tf.sin(self._max_angle)
                self._ranks = tf.cast(
                    tf.linspace(
                        lower_rank_cutoff, upper_rank_cutoff, self._sample_count
                    ),
                    tf.float64,
                )
                self._angles = tf.asin(self._ranks)


class RandomLambertianAngularDistribution(AngularDistributionBase):
    """
        For this source, rank will be the sine of the angle, so that the maximum rank
        will have magnitude sin(max(abs(angle_limits))).  Rank will be distributed 
        uniformally.
        
    """

    def __init__(
        self,
        min_angle,
        max_angle,
        sample_count,
        name="RandomLambertianAngularDistribution",
    ):
        super().__init__(min_angle, max_angle, sample_count, name=name)

    def build(self):
        with tf.name_scope(self._name) as scope:
            with tf.control_dependencies(
                self._angle_limit_validation_ops(-PI / 2.0, PI / 2.0)
            ):
                lower_rank_cutoff = tf.sin(self._min_angle)
                upper_rank_cutoff = tf.sin(self._max_angle)
                self._ranks = tf.random_uniform(
                    (self._sample_count,),
                    lower_rank_cutoff,
                    upper_rank_cutoff,
                    dtype=tf.float64,
                )
                self._angles = tf.asin(self._ranks)


# =====================================================================================


class BasePointDistributionBase(ABC):
    """
    Abstract implementation of a base point distribution, which defines the bare
    minimum interface that all base point distributions should implement.  There is
    much less here because I envision this class being much more diverse.
    
    """

    @abstractmethod
    def __init__(self, name="BasePointDistribution"):
        """
        A constructor should not construct any tf ops, it should only store values 
        for use by the class at a later time.  All base point distribution 
        constructors should accept a name keyword argument, which is used
        to define a namespace in which all tf ops constructed by the class are placed.
        
        """
        self._name = name
        self._base_points = None
        self._ranks = None

    @abstractmethod
    def build(self):
        """
        All subclasses must override this method.  This method will use the values
        stored inside the class in the constructor to build the TF ops that
        generate the distribution.  The ops in here should list any parameter 
        validation ops as dependencies.
        
        This method is separated from the constructor for cleanliness of the tf graph:
        It will allow the ops generated by this class to be easily colocated with the
        other ops used to build a source.
        
        The build function should overwrite self._base_points which represents the  
        set of base points built by the class.
        
        The build function may also overwrite self._ranks, if you want the subclass 
        to use base point ranks.  Otherwise this may be skipped.
        
        The ops in this function should be build within a namescope unique to the
        instance.  Use:
        
        with tf.name_scope(self._name) as scope:
        
        """
        pass

    @property
    def needs_build(self):
        if self._base_points is None:
            return True
        else:
            return False

    @property
    def base_points(self):
        """
        If overwritten, this should not add any ops to the tf graph.
        Should be a tuple of 1-D tensors, (x_points, y_points).
        
        """
        if self._base_points is None:
            raise RuntimeError(
                f"{self.__class__.__name__}: attempted to access "
                "base points before calling build."
            )
        return self._base_points

    @property
    def ranks(self):
        """
        If overwritten, this should not add any ops to the tf graph.
        Should be a 1-D tensor with the same length as the x and y points, but may
        also be None.
        
        """
        return self._ranks

class ManualBasePointDistribution(BasePointDistributionBase):
    """
    This class allows you to package a set of points you calculated yourself into
    the format for use with a source, and does nothing except cast the inputs
    to tf.float64.  Can accept tensors or python objects.  Does no error checking.
    Inputs should be 1-D tensor-like objects, and should all have the same length.
    Ranks may be None.
    
    """
    def __init__(
        self,
        x_points,
        y_points,
        ranks=None,
        name="ManualBasePointDistribution"
    ):
        super().__init__(name=name)
        self._x_points = x_points
        self._y_points = y_points
        self._ranks = ranks
        
    def build(self):
        with tf.name_scope(self._name) as scope:
            self._base_points = (
                tf.cast(self._x_points, tf.float64),
                tf.cast(self._y_points, tf.float64)
            )
            if self._ranks is not None:
                self._ranks = tf.cast(self._ranks, tf.float64)

class BeamPointBase(BasePointDistributionBase):
    """
    Base class for beam-type base points distributions, which are defined by an angle,
    central_angle, and two distances that denote the width of the beam perpendicular
    to the angle.  The coordinates returned by beams will be relative to the origin
    (so they should be interpreted as relative coordinates).  The base points will 
    lie along a line perpendicular to central_angle, and will extend outward by the
    distances given to the constructor.  Positive distances correspond to points 
    CCW to the central_angle, and negative distances correspond to points CW to the
    central_angle.
    
    The central_angle may be fed to the constructor.  By default it will take the 
    value 0.0.  However, to ease use with sources, a single-use setter is included
    with the beam classes.  The intent is to allow the user to pass a 
    BeamPointDistribution to a source constructor without needing to define the 
    central_angle; instead the central_angle of the BeamPointDistribution will be
    set by the source.  This setter must be called before the distribution's build
    method is called, or else an exception will be raised.
    
    The rank generated by this distribution will have its zero at the relative origin 
    of the beam, and will have magnitude 1 for the point(s) farthest from the origin.
    
    """

    def __init__(
        self,
        beam_start,
        beam_end,
        sample_count,
        name="BeamPointDistribution",
        central_angle=0.0,
    ):
        super().__init__(name=name)
        self._beam_start = beam_start
        self._beam_end = beam_end
        self._sample_count = sample_count
        self._central_angle = central_angle

    @property
    def central_angle(self):
        return self._central_angle

    @central_angle.setter
    def central_angle(self, val):
        if self._base_points is None:
            self._central_angle = val
        else:
            raise RuntimeError(
                f"{self.__class__.__name__}: Too late to set central_angle!  "
                "Build has already been called."
            )

    def _parametrize_beam(self):
        """
        Utility to be called inside build that interprets beam_start, beam_end, and 
        central_angle.  Calculates the endpoints of the beam and the limits on the 
        beam rank.  Beam rank can then be interpreted as a parameter that generates
        beam points on a line from the origin to endpoint.
        
        """
        self._beam_start = tf.cast(self._beam_start, tf.float64)
        self._beam_end = tf.cast(self._beam_end, tf.float64)
        self._central_angle = tf.cast(self._central_angle, tf.float64)
        
        validate_endpoints = tf.assert_less(
            self._beam_end,
            self._beam_start,
            message=f"{self.__class__.__name__}: beam_end must be less than "
            f"beam_start.",
        )

        with tf.control_dependencies([validate_endpoints]):
            rank_scale = tf.reduce_max(
                tf.abs(tf.stack([self._beam_start, self._beam_end]))
            )
            self._max_rank = self._beam_start / rank_scale
            self._min_rank = self._beam_end / rank_scale

            self._endpoint_x = self._beam_start * tf.cos(self._central_angle + PI/2.0)
            self._endpoint_y = self._beam_start * tf.sin(self._central_angle + PI/2.0)

    def _build_points(self):
        """
        Utility that takes the rank and the endponts and constructs the actual
        base points.
        """
        self._base_points = (
            self._endpoint_x * self._ranks / self._max_rank,
            self._endpoint_y * self._ranks / self._max_rank,
        )


class StaticUniformBeam(BeamPointBase):
    def __init__(
        self,
        beam_start,
        beam_end,
        sample_count,
        name="StaticUniformBeam",
        central_angle=0.0,
    ):
        super().__init__(
            beam_start, beam_end, sample_count, name=name, central_angle=central_angle
        )

    def build(self):
        with tf.name_scope(self._name) as scope:
            self._parametrize_beam()
            self._ranks = tf.linspace(
                self._min_rank, self._max_rank, self._sample_count
            )
            self._build_points()


class RandomUniformBeam(BeamPointBase):
    def __init__(
        self,
        beam_start,
        beam_end,
        sample_count,
        name="RandomUniformBeam",
        central_angle=0.0,
    ):
        super().__init__(
            beam_start, beam_end, sample_count, name=name, central_angle=central_angle
        )

    def build(self):
        with tf.name_scope(self._name) as scope:
            self._parametrize_beam()
            self._ranks = tf.random_uniform(
                (self._sample_count,), self._min_rank, self._max_rank, dtype=tf.float64
            )
            self._build_points()


class AperaturePointBase(BasePointDistributionBase):
    """
    Base class for aperature-type base point distributions, which are defined by two
    2-D points that define the edges of the aperature.  This class generates base 
    points along the line segment bounded by the end points.  Convenient when you want
    to specify absolute positions for the edges of the source, rather than relative
    ones.
    
    A point with rank zero will be located at the start point, and a point with rank 
    one will be located at the end point.
    
    """

    def __init__(
        self, start_point, end_point, sample_count, name="AperaturePointDistribution"
    ):
        super().__init__(name=name)
        self._start_point = start_point
        self._end_point = end_point
        self._sample_count = sample_count

    @abstractmethod
    def _build_ranks(self):
        """
        This abstract method will generate the point ranks, according to some
        distribution.  It will be called inside build, and must set self._ranks
        
        """
        pass

    def build(self):
        """
        This method may be overridden, though I think this implementation will cover
        most use cases for this class.
        
        """
        with tf.name_scope(self._name) as scope:
            self._start_point = tf.cast(self._start_point, tf.float64)
            self._end_point = tf.cast(self._end_point, tf.float64)
        
            start_shape = tf.shape(self._start_point)
            end_shape = tf.shape(self._end_point)
            correct_shape = (2,)

            validation_ops = [
                tf.assert_equal(
                    start_shape,
                    correct_shape,
                    message=f"{self.__class__.__name__}: start_point must have "
                    f"shape exactly equal to (2,).",
                ),
                tf.assert_equal(
                    end_shape,
                    correct_shape,
                    message=f"{self.__class__.__name__}: end_point must have "
                    f"shape exactly equal to (2,).",
                ),
                tf.assert_scalar(
                    self._sample_count,
                    message=f"{self.__class__.__name__}: sample_count must be scalar.",
                ),
                tf.assert_positive(
                    self._sample_count,
                    message=f"{self.__class__.__name__}: sample_count must be > 0.",
                ),  # Displays error message for -1, but not -10?!? :(
            ]

            with tf.control_dependencies(validation_ops):
                start_x = self._start_point[0]
                start_y = self._start_point[1]
                end_x = self._end_point[0]
                end_y = self._end_point[1]

            self._build_ranks()
            self._base_points = (
                start_x + self._ranks * (end_x - start_x),
                start_y + self._ranks * (end_y - start_y),
            )


class StaticUniformAperaturePoints(AperaturePointBase):
    def __init__(
        self, start_point, end_point, sample_count, name="StaticUniformAperaturePoints"
    ):
        super().__init__(start_point, end_point, sample_count, name=name)

    def _build_ranks(self):
        self._ranks = tf.cast(tf.linspace(0.0, 1.0, self._sample_count), tf.float64)


class RandomUniformAperaturePoints(AperaturePointBase):
    def __init__(
        self, start_point, end_point, sample_count, name="RandomUniformAperaturePoints"
    ):
        super().__init__(start_point, end_point, sample_count, name=name)

    def _build_ranks(self):
        self._ranks = tf.random_uniform(
            (self._sample_count,), 0.0, 1.0, dtype=tf.float64
        )


# =====================================================================================


class SourceBase(ABC):
    """
    Abstract implementation of a source, which defines the bare minimum interface 
    that all sources should implement.
    
    The standard way of using a source will be to create an instances of the needed
    parameter distributions before calling the source constructor, and letting the
    source call the build method on its parameters, because this will colocate the
    parameter ops inside the namespace defined by the source.  But if you do not want
    this behavior, or if you want to re-use some of the parameter distributions, you
    may build the parameters before feeding them to the source.  Sources will check
    whether their parameters have already been built, and will build them if not.
    
    Sources should build themselves (add ops to the graph) in their constructor.
    
    Sources should expose their distributions as read-only properties.  They should
    also expose the expanded (possibly densified) values of each of their parameters
    as read-only properties.  This is necessary because, if you plan to use one of the
    distribution ranks to specify target locations for an optimizer, you need to
    use the possibly densified version of the ranks.  So you should use the source's
    version of the ranks, not the distribution's version.
    
    """

    @abstractmethod
    def __init__(self, name="SourceBase", dense=True):
        """
        If a source is dense, that means that rays will be generated with every
        combination of the values of each of the parameters.  This is convenient for
        static sources (sources that use static distributions) since it generates
        rays that span the entire range of specified inputs.  It is not recommended
        that sources that use random distributions choose to be dense, simply because
        they will be less random.  But the source will work either way.
        
        """
        self._name = name
        self._rays = None
        self._dense = dense

    @abstractmethod
    def _make_dense(self):
        """
        Inspect the parameter distributions, and use meshgrid and reshape to densify 
        their values.  This function should set the internal copy of the values, 
        which will used by the source and be passed out of the source as read-only 
        properties.
        
        """
        pass

    @abstractmethod
    def _make_undense(self):
        """
        Inspect the parameters and set the internal copy of the values, which will 
        used by the source and be passed out of the source as read-only properties.  
        Either _make_dense or _make_undense should always be called exactly once in 
        generating the source, depending on whether dense is true or not.
        
        """
        pass

    @property
    def is_dense(self):
        return self._dense

    @property
    def name(self):
        return self._name

    @property
    def rays(self):
        """If overridden, should not add any ops to the graph."""
        return self._rays


class PointSource(SourceBase):
    """
    This class accepts a location, an angular distribution and central angle, and a 
    set of wavelengths to make rays that eminate from a single point in space.  The 
    angular distribution is interpreted as angles relative to central_angle, but they
    can be interpreted as absolute angles simply by setting central_angle to zero.
    
    """

    def __init__(
        self,
        center,
        central_angle,
        angular_distribution,
        wavelengths,
        name="PointSource",
        dense=True,
        start_on_center=True,
        ray_length=1.0,
    ):
        super().__init__(name, dense)
        with tf.name_scope(self._name) as scope:
            self._center = tf.cast(center, tf.float64)
            self._central_angle = tf.cast(central_angle, tf.float64)
            self._wavelengths = tf.cast(wavelengths, tf.float64)

            self._angular_distribution = angular_distribution
            if self._angular_distribution.needs_build:
                self._angular_distribution.build()

            if self._dense:
                self._make_dense()
            else:
                self._make_undense()

            validation_ops = [
                tf.assert_equal(
                    tf.shape(self._center),
                    (2,),
                    message=f"{self.__class__.__name__}: Center must have shape "
                    f"exactly equal to (2,).",
                ),
                tf.assert_scalar(
                    self._central_angle,
                    message=f"{self.__class__.__name__}: central_angle must be "
                    f"scalar.",
                ),
            ]
            with tf.control_dependencies(validation_ops):
                ray_count = tf.shape(self._angles)
                self._angles = self._angles + self._central_angle
            start_x = tf.broadcast_to(self._center[0], ray_count)
            start_y = tf.broadcast_to(self._center[1], ray_count)
            end_x = start_x + ray_length * tf.cos(self._angles)
            end_y = start_y + ray_length * tf.sin(self._angles)

            if start_on_center:
                self._rays = tf.stack(
                    [start_x, start_y, end_x, end_y, self._wavelengths], axis=1
                )
            else:
                self._rays = tf.stack(
                    [end_x, end_y, start_x, start_y, self._wavelengths], axis=1
                )

    def _make_dense(self):
        self._angles = tf.cast(self._angular_distribution.angles, tf.float64)
        self._angle_ranks = self._angular_distribution.ranks

        angles, wavelengths = tf.meshgrid(self._angles, self._wavelengths)
        if self._angle_ranks is not None:
            angle_ranks, _ = tf.meshgrid(self._angle_ranks, self._wavelengths)

            self._angle_ranks = tf.reshape(angle_ranks, (-1,))
        self._angles = tf.reshape(angles, (-1,))
        self._wavelengths = tf.reshape(wavelengths, (-1,))

    def _make_undense(self):
        self._angles = tf.cast(self._angular_distribution.angles, tf.float64)
        self._angle_ranks = self._angular_distribution.ranks

        angle_shape = tf.shape(self._angles)
        wavelength_shape = tf.shape(self._wavelengths)
        validation_ops = [
            tf.assert_equal(
                angle_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many angles as wavelengths.",
            )
        ]
        with tf.control_dependencies(validation_ops):
            self._angles = tf.identity(self._angles)

    @property
    def angles(self):
        return self._angles

    @property
    def angle_ranks(self):
        return self._angle_ranks

    @property
    def wavelengths(self):
        return self._wavelengths

    @property
    def angular_distribution(self):
        return self._angular_distribution


class AngularSource(SourceBase):
    """
    This class accepts a location, the center of the source; an angle, the central 
    angle that the source points to; an angular distribution of angles relative to 
    the central_angle at which to point rays; a base_point_distribution, a set of
    points at which to start the rays; and a set of wavelengths.
    
    The source will attempt to feed central_angle to the base_point_distribution, in
    case it is a beam-type distribution, but if the distribution does not accept a 
    central_angle, it will do nothing.  However, setting the central_angle requires 
    that the base_point_distribution not already be built.  It won't fail in this
    case, but it will do nothing silently.  If you need to feed an already built
    base_point_distribution that requires a central_angle, you will need to manually
    feed that central_angle to the base_point_distribution's constructor.    
    
    """

    def __init__(
        self,
        center,
        central_angle,
        angular_distribution,
        base_point_distribution,
        wavelengths,
        name="AngularSource",
        dense=True,
        start_on_center=True,
        ray_length=1.0,
    ):
        super().__init__(name, dense)
        with tf.name_scope(self._name) as scope:
            self._center = tf.cast(center, tf.float64)
            self._central_angle = tf.cast(central_angle, tf.float64)
            self._wavelengths = tf.cast(wavelengths, tf.float64)

            self._angular_distribution = angular_distribution
            if self._angular_distribution.needs_build:
                self._angular_distribution.build()
            self._base_point_distribution = base_point_distribution
            try:
                self._base_point_distribution.central_angle = self._central_angle
            except (RuntimeError, AttributeError):
                # Two exceptions may be raised: RuntimeError, if the distribution has
                # already been built, and AttributeError, if the distribution doesn't
                # accept a central_angle.  In either case, do nothing.
                # Actually, printing a warning or something might be appropriate, but
                # I am not sure.
                pass
            if self._base_point_distribution.needs_build:
                self._base_point_distribution.build()

            if self._dense:
                self._make_dense()
            else:
                self._make_undense()

            validation_ops = [
                tf.assert_equal(
                    tf.shape(self._center),
                    (2,),
                    message=f"{self.__class__.__name__}: Center must have shape "
                    f"exactly equal to (2,).",
                ),
                tf.assert_scalar(
                    self._central_angle,
                    message=f"{self.__class__.__name__}: central_angle must be "
                    f"scalar.",
                ),
            ]
            with tf.control_dependencies(validation_ops):
                self._angles = self._angles + self._central_angle
            start_x = self._center[0] + self._base_points_x
            start_y = self._center[1] + self._base_points_y
            end_x = start_x + ray_length * tf.cos(self._angles)
            end_y = start_y + ray_length * tf.sin(self._angles)

            if start_on_center:
                self._rays = tf.stack(
                    [start_x, start_y, end_x, end_y, self._wavelengths], axis=1
                )
            else:
                self._rays = tf.stack(
                    [end_x, end_y, start_x, start_y, self._wavelengths], axis=1
                )

    def _make_dense(self):
        self._angles = tf.cast(self._angular_distribution.angles, tf.float64)
        self._angle_ranks = self._angular_distribution.ranks
        self._base_points_x, self._base_points_y = (
            self.base_point_distribution.base_points
        )
        self._base_point_ranks = self._base_point_distribution.ranks

        angles, wavelengths, base_x = tf.meshgrid(
            self._angles, self._wavelengths, self._base_points_x
        )
        _, _, base_y = tf.meshgrid(
            self._angles,
            self._wavelengths,
            self._base_points_y
        )
        if self._angle_ranks is not None:
            angle_ranks, _, _ = tf.meshgrid(
                self._angle_ranks, self._wavelengths, self._base_points_x
            )
            self._angle_ranks = tf.reshape(angle_ranks, (-1,))
        if self._base_point_ranks is not None:
            _, _, base_point_ranks = tf.meshgrid(
                self._angle_ranks, self._wavelengths, self._base_point_ranks
            )
            self._base_point_ranks = tf.reshape(base_point_ranks, (-1,))

        self._angles = tf.reshape(angles, (-1,))
        self._wavelengths = tf.reshape(wavelengths, (-1,))
        self._base_points_x = tf.reshape(base_x, (-1,))
        self._base_points_y = tf.reshape(base_y, (-1,))

    def _make_undense(self):
        self._angles = tf.cast(self._angular_distribution.angles, tf.float64)
        self._angle_ranks = self._angular_distribution.ranks
        self._base_points_x, self._base_points_y = (
            self.base_point_distribution.base_points
        )
        self._base_point_ranks = self._base_point_distribution.ranks

        angle_shape = tf.shape(self._angles)
        wavelength_shape = tf.shape(self._wavelengths)
        base_x_shape = tf.shape(self._base_points_x)
        base_y_shape = tf.shape(self._base_points_y)
        validation_ops = [
            tf.assert_equal(
                angle_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many angles as wavelengths.",
            ),
            tf.assert_equal(
                base_x_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many base points as wavelengths.",
            ),
            tf.assert_equal(
                base_y_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many base points as wavelengths.",
            ),
        ]
        with tf.control_dependencies(validation_ops):
            self._angles = tf.identity(self._angles)

    @property
    def angles(self):
        return self._angles

    @property
    def angle_ranks(self):
        return self._angle_ranks

    @property
    def wavelengths(self):
        return self._wavelengths

    @property
    def base_points(self):
        return (self._base_points_x, self._base_points_y)

    @property
    def base_point_ranks(self):
        return self._base_point_ranks

    @property
    def angular_distribution(self):
        return self._angular_distribution

    @property
    def base_point_distribution(self):
        return self._base_point_distribution
        
class AperatureSource(SourceBase):
    """
    This source does not use an angular distribution, and instead makes rays between
    two sets of points.  Useful if you know your input light is bounded by two 
    aperatures, and you don't want to calculate angles.
    
    This source will not attempt to feed central_angle to the base point distributions
    because there is no angle, and this source isn't expceted to be used with
    beam distributions.  But if you feed your own central_angle to the distribution,
    you can still use a beam point distribution with this class.
    
    """

    def __init__(
        self,
        start_point_distribution,
        end_point_distribution,
        wavelengths,
        name="AperatureSource",
        dense=True,
    ):
        super().__init__(name, dense)
        with tf.name_scope(self._name) as scope:
            self._wavelengths = tf.cast(wavelengths, tf.float64)
            self._start_point_distribution = start_point_distribution
            if self._start_point_distribution.needs_build:
                self._start_point_distribution.build()
            self._end_point_distribution = end_point_distribution
            if self._end_point_distribution.needs_build:
                self._end_point_distribution.build()

            self._start_x, self._start_y = (self.start_point_distribution.base_points)
            self._end_x, self._end_y = (self.end_point_distribution.base_points)
            self._start_ranks = self._start_point_distribution.ranks
            self._end_ranks = self._end_point_distribution.ranks

            if self._dense:
                self._make_dense()
            else:
                self._make_undense()

            self._rays = tf.stack([
                self._start_x,
                self._start_y,
                self._end_x,
                self._end_y,
                self._wavelengths
            ], axis=1)

    def _make_dense(self):
        start_x, end_x, wavelengths = tf.meshgrid(
            self._start_x, self._end_x, self._wavelengths
        )
        start_y, end_y, _ = tf.meshgrid(
            self._start_y, self._end_y, self._wavelengths
        )
        if self._start_ranks is not None:
            start_ranks, _, _ = tf.meshgrid(
                self._start_ranks, self._end_x, self._wavelengths
            )
            self._start_ranks = tf.reshape(start_ranks, (-1,))
        if self._end_ranks is not None:
            end_ranks, _, _ = tf.meshgrid(
                self._end_ranks, self._end_x, self._wavelengths
            )
            self._end_ranks = tf.reshape(start_ranks, (-1,))
        
        self._wavelengths = tf.reshape(wavelengths, (-1,))
        self._start_x = tf.reshape(start_x, (-1,))
        self._start_y = tf.reshape(start_y, (-1,))
        self._end_x = tf.reshape(end_x, (-1,))
        self._end_y = tf.reshape(end_y, (-1,))

    def _make_undense(self):
        wavelength_shape = tf.shape(self._wavelengths)
        start_x_shape = tf.shape(self._start_x)
        start_y_shape = tf.shape(self._start_y)
        end_x_shape = tf.shape(self._end_x)
        end_y_shape = tf.shape(self._end_y)
        validation_ops = [
            tf.assert_equal(
                start_x_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many start_x points as wavelengths.",
            ),
            tf.assert_equal(
                start_x_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many start_x points as wavelengths.",
            ),
            tf.assert_equal(
                start_x_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many start_x points as wavelengths.",
            ),
            tf.assert_equal(
                start_x_shape,
                wavelength_shape,
                message=f"{self.__class__.__name__}: For un dense source, need "
                f"exactly as many start_x points as wavelengths.",
            ),
        ]
        with tf.control_dependencies(validation_ops):
            self._wavelengths = tf.identity(self._wavelengths)

    @property
    def wavelengths(self):
        return self._wavelengths

    @property
    def start_points(self):
        return (self._start_x, self._start_y)

    @property
    def start_point_ranks(self):
        return self._start_ranks

    @property
    def end_points(self):
        return (self._end_x, self._end_y)

    @property
    def end_point_ranks(self):
        return self._end_ranks

    @property
    def start_point_distribution(self):
        return self._start_point_distribution
        
    @property
    def end_point_distribution(self):
        return self._end_point_distribution
