"""
Graph-like utilities for the vertices of meshes.  Tools for smoothing the gradient of a 3D
parametric surface.

These functions generate data structures that represent directed acyclic graphs that
describe connections between vertices of a mesh.  They are intended to help construct
sensible gradient cumulative summation matrices to help prevent parametric meshes from
developing rough surfaces.  These functions tend to produce lists of set.  Each set in the 
list corresponds to one vertex in the mesh.  And each element in each set represents
connections between that vertex and others in the mesh.

All the functions are public, but most users will only need to call gradient_accumulator.

Please be aware that this module does NOT use tensorflow.  It uses numpy instead.
"""

import itertools

import numpy as np
import pyvista as pv

# =========================================================================================

def gradient_accumulator_1p(mesh, origin=(0, 0, 0)):
    """
    Version in which children have only 1 parent.
    
    Builds a smoothing gradient_accumulator matrix for a mesh, around a starting point.
    
    Origin should be a point (3-tuple or 3-vector) that ideally sits at the center of the
    mesh, or wherever you think is a good place to build the accumulator around.  This
    function will find the closest point in the mesh to the origin point, and build the
    accumulator around that point.
    
    Parameters
    ----------
    mesh : pyvista PolyData
        The pyvista mesh that was used to paramatrize the parametric surface.
    origin : 3-tuple / 3-vector.
    
    Returns
    -------
    accumulator : np.array
        A square array whose side length is equal to the number of points in the mesh.
        This matrix can be left-multiplied with the gradient generated by the optimizer
        to perform smoothing gradient accumulation that will hopefully prevent the surface
        from becomming too rough due to uneven training.  The result of this left-multiply
        can be used to update the parameters.
    relationship_data : dict
        Holds the four relationship graphs generated in the course of calculating the
        accumulator.  These are convenient if you also want to use neighbor smoothing, and
        can be passed to that function to save computation time.  The dict has four keys for 
        the four graphs: "decendant", "child", "parent", and "ancestor".  It also has one
        a key, "top_parent", the index of the point that was chosen as the origin of the
        accumulator, and a key "unique_edges" for the set of unique edges in the mesh.
    
    """
    origin = np.array(origin, dtype=np.float64)
    top_parent = get_closest_point(mesh, origin)
    unique_edges = get_unique_edges(mesh)
    
    out_dict = {"top_parent": top_parent, "unique_edges": unique_edges}
    out_dict["descendant"], out_dict["child"], out_dict["parent"], out_dict["ancestor"] = \
        find_all_relationships(top_parent, mesh, unique_edges)
        
    accumulator = connections_to_array(out_dict["descendant"])
    return accumulator, out_dict

# =========================================================================================

def get_closest_point(mesh, target):
    """
    Gets the index of the point in the mesh closest (in cartesian distance) to traget.
    """
    distance = np.sum((mesh.points - target)**2, axis=1)
    return np.argmin(distance)

# -----------------------------------------------------------------------------------------
    
def get_unique_edges_1p(mesh):
    """
    Given a pyvista mesh, generate a set of 2-element frozenset that encodes every
    edge (line between vertices) in the mesh.  The edges are unique.  Elements of edges are 
    indices into the mesh's points.
    """
    faces = mesh.faces
    faces = np.reshape(faces, (-1, 4))
    
    # these are each side of each triangle
    a = faces[:,1:3]
    b = faces[:,2:4]
    c = faces[:,1:4:2]
    all_edges = np.concatenate([a, b, c], axis=0)
    
    # use set as a convenient way of removing duplicates
    deduplicated_edges = {frozenset(e) for e in all_edges}
    return deduplicated_edges
    
# -----------------------------------------------------------------------------------------

def neighbors_from_edges(start, edges):
    """
    Finds all points adjacent to the parent point.  Parent is the index of a vertex, and
    edges is a uniqueified set of the indices of each edge.
    """
    neighbor_list = [edge for edge in edges if start in edge]
    neighbor_set = set(
        [neighbor for frozen_neighbor in neighbor_list for neighbor in frozen_neighbor]
    )
    
    return neighbor_set - set([start])
    
# -----------------------------------------------------------------------------------------

def neighbors_from_faces(point, faces):
    """
    Returns a set of all points that are next to point.  Uses faces (formatted as a list of 
    sets) to compute this instead of edges.
    """
    out = set()
    for face in faces:
        if point in face:
            out |= face
    out.discard(point)
    return out

# -----------------------------------------------------------------------------------------

def find_all_relationships_1p(top_parent, mesh, edges):
    """
    Version in which children have only 1 parent.
    
    Given a mesh, and top_parent, the index of a point in the mesh at which to start,
    generates a list of sets, one for each point in the mesh, that contains the indices of
    each point considered a child of that point.  If a set in the output is empty, that point
    is a lowest-level child.
    
    The first returns is a list of all decendants, for each vertex, and the second return
    is a list of all direct children, for each vertex.
    """
    points = mesh.points
    point_count = points.shape[0]
    top_parent_position = np.array(points[top_parent])
    all_children = set(range(point_count))
    child_list = [set()] * point_count
    parent_list = [set()] * point_count
    ancestor_list = [set()] * point_count
    
    # claim the top parent
    unclaimed_children = all_children - set([top_parent])
    
    # find all children (breadth first)
    queue = [top_parent]
    reverse_queue = []
    while queue:
        parent = queue.pop(0)
        reverse_queue.append(parent)
        
        # compute the children of parent
        parents_children = neighbors_from_edges(parent, edges) & unclaimed_children
        unclaimed_children.difference_update(parents_children)
        child_list[parent] = parents_children
        
        # queue up the children to have their children found
        for child in parents_children:
            queue.append(child)
            parent_list[child] = set([parent])
            ancestor_list[child] = parent_list[child] | ancestor_list[parent]
            
        #sort the queue by distance from the top parent
        queue_points = np.take(points, queue, axis=0)
        distance = np.sum((queue_points - top_parent_position)**2, axis=1)
        queue = list(np.take(queue, np.argsort(distance)))
        
    # reverse_queue gets filled with each node that gets any children, in the order
    # that they are filled.  Go through it in reverse, to accumulate all descendants.
    descendant_list = child_list.copy()
    for target in reverse_queue[::-1]:
        for child in child_list[target]:
            descendant_list[target] = descendant_list[target] | descendant_list[child]
    
    return descendant_list, child_list, parent_list, ancestor_list

# -----------------------------------------------------------------------------------------

def get_faces_as_sets(mesh):
    return [set(face) for face in np.reshape(mesh.faces, (-1, 4))[:,1:]]

# -----------------------------------------------------------------------------------------

def find_generations(top_parent, mesh):
    """
    Breaks the points in mesh into generations, starting with top_parent.  The first
    generation contains only top_parent, the second contains top_parent's neighbors, and
    sucessive generations contain sucessive neighbors that haven't already been accounted
    for.
    """
    generations = [set([top_parent])]
    faces = get_faces_as_sets(mesh)
    point_count = mesh.points.shape[0]
    remaining_points = set(range(point_count)) - generations[0]
    
    print(f"remaining points: {remaining_points}")
    
    while remaining_points:
        neighbors = set()
        for point in generations[-1]:
            neighbors |= neighbors_from_faces(point, faces)
        neighbors &= remaining_points
        remaining_points -= neighbors
        generations.append(neighbors)
    
    return generations

# =========================================================================================

def raw_mesh_parametrization_tools(mesh, top_parent):
    """
    Raw version of the function, which returns extra information for debugging.
    
    Determines which of a face's vertices that face is allowed to update, in a way that
    tries to minimize competition between adjacent faces.
    """
    face_sets = get_faces_as_sets(mesh)
    face_count = len(face_sets)
    point_count = mesh.points.shape[0]
    faces = np.reshape(mesh.faces, (-1, 4))[:,1:]
    face_movable_vertices = [set()] * face_count
    faces_to_visit = set(range(face_count))
    active_edge = set([top_parent])
    last_edge = set()
    available_vertices = set(range(point_count))
    vertex_parents = [set()] * point_count
    vertex_ancestors = [set()] * point_count
    missed_vertices = set(range(point_count))
            
    #counter = 0 # to prevent infinite loops
    while faces_to_visit:
        #counter += 1
        #if counter >= 5:
        #    break
        
        next_active_edge = set() 
        faces_just_visited = set()   
        available_vertices -= active_edge
        # work on face_movable_vertices
        for face in faces_to_visit:
            for vertex in active_edge:
                if vertex in face_sets[face]:
                    movable_vertices = face_sets[face] & available_vertices
                    next_active_edge |= movable_vertices
                    face_movable_vertices[face] = movable_vertices
                    faces_just_visited.add(face)
                    
        # work on vertex ancestors
        # this may miss vertices along the edge after all faces have been depleted.
        for vertex in active_edge:
            missed_vertices.remove(vertex)
            vertex_parents[vertex] = neighbors_from_faces(vertex, face_sets) & last_edge
            vertex_ancestors[vertex] = vertex_parents[vertex].copy()
            for parent in vertex_parents[vertex]:
                vertex_ancestors[vertex] |= vertex_ancestors[parent]
        
        # step the sets to the next edge
        faces_to_visit -= faces_just_visited
        last_edge = active_edge
        active_edge = next_active_edge
    
    # take care of any missed vertices    
    for vertex in missed_vertices:
        vertex_parents[vertex] = neighbors_from_faces(vertex, face_sets) - missed_vertices
        vertex_ancestors[vertex] = vertex_parents[vertex].copy()
        for parent in vertex_parents[vertex]:
            vertex_ancestors[vertex] |= vertex_ancestors[parent]
    
    return (
        face_movable_vertices,
        vertex_ancestors,
        vertex_parents,
        missed_vertices
    )

# -----------------------------------------------------------------------------------------

def mesh_parametrization_tools(mesh, top_parent):
    """
    Determines which of a face's vertices that face is allowed to update, in a way that
    tries to minimize competition between adjacent faces.
    
    Parameters
    ----------
    mesh : pyvista mesh
        The mesh that is being used to parametrize the surface.
    top_parent : int
        The index of the vertex to base the parametrization around.  Typically found
        via get_closest_point()
        
    Returns
    -------
    vertex_update_map : (n, 3) np boolean array
        This array has a row for each face in the mesh, and the values in the columns
        are True wherever a face is allowed to move one of its vertices.  Should be fed
        to your TriangleBoundary.
    gradient_accumulator : (n, n) np float64 array
        This array can be left-multiplied onto the gradient to accomplish an accumulating
        effect; when one vertex is moved others connected to it will also get moved, to
        reduce faces competing with each other.
    
    """
    face_movable_vertices, vertex_ancestors, vertex_parents, missed_vertices = \
        raw_mesh_parametrization_tools(mesh, top_parent)
    
    return (
        movable_to_updatable(mesh, face_movable_vertices),
        connections_to_array(vertex_ancestors)
    )

# =========================================================================================

def gaussian_weights(sigma, count):
    """
    Generates a list of values calculated with a gaussian, for use with the smoothing tool.
    Not normalized, because the smoother does that on its own.
    """
    x = np.arange(count) / sigma
    return np.exp(-.5*x**2)

# -----------------------------------------------------------------------------------------

def mesh_smoothing_tool(mesh, weights):
    """
    Tool for smoothing a mesh (that works on the mesh's parameters).
    
    This tool generates a matrix that has the effect of smoothing a mesh when left-
    multiplied with the parameters.
    
    Parameters
    ----------
    mesh : pyvista mesh
        The mesh that is being used to parametrize the surface.
    weights : list of number
        A list that describes the relative weight to give to each generation of neighbors.
        Should have at least two elements, or no smoothing will occur.  The first number
        relates to the point itself, the second number to the points neighbors, the third to
        the neighbors' neighbors, and so on.  Does not need to be normalized, as this 
        function will automatically account for that, given that different points can have
        different numbers of neighbors.
        
        Example: if weights = [x, y, z] and for N = x + y + z, each vertex on the mesh will
        keep x/N of its magnitude, y/N of the magnitude will be distributed evenly across
        all neighbors, and z/N value will be distributed evenly across all neighbors' 
        neighbors.
    
    Returns
    -------
    smoother : (n, n) np float64 array
        This array can be left-multiplied onto the gradient to accomplish a smoothing
        effect on the mesh - sharp features will be spread out to make the surface more
        uniform.
    """
    face_sets = get_faces_as_sets(mesh)
    point_count = mesh.points.shape[0]
    neighbor_depth = len(weights)
    nth_neighbors = [None] * point_count
    weights = weights / np.sum(weights)
    
    # construct nth_neighbors, which is a list of list of sets.  The first list
    # indexes points/vertices in the mesh, the second list indexes sucessive sets of
    # neighbors, with the first list being the zero-th order neighbor, (the point itself)
    # and each set contains the index of the points that are that level of neighbor from
    # each point.
    for point in range(point_count):
        nth_neighbors[point] = [set([point])]
        taken_neighbors = nth_neighbors[point][0].copy()
        current_edge = nth_neighbors[point][0].copy()
        for neighbor_order in range(1, neighbor_depth):
            new_neighbors = set()
            for edge_point in current_edge:
                new_neighbors |= neighbors_from_faces(edge_point, face_sets)
            new_neighbors -= taken_neighbors
            
            nth_neighbors[point].append(new_neighbors)
            current_edge = new_neighbors
            taken_neighbors |= new_neighbors

    # now build the smoothing matrix
    smoother = np.zeros((point_count, point_count), dtype=np.float64)
    for point in range(point_count):
        for neighbor_order in range(neighbor_depth):
            neighbors = nth_neighbors[point][neighbor_order]
            weight = weights[neighbor_order] / len(neighbors)
            smoother[point, list(neighbors)] = weight
        
    return smoother

# =========================================================================================

def movable_to_updatable(mesh, face_movable_vertices):
    """
    Converts a list of sets that dictates which vertices each face is allowed to move into
    a boolean array that can be used to mask away updates.
    """
    face_updates = []
    face_count = len(face_movable_vertices)
    faces = np.reshape(mesh.faces, (-1, 4))[:,1:]
    
    for face in range(face_count):
        face_updates.append(
            [True if vertex in face_movable_vertices[face] else False \
                for vertex in faces[face]
            ]
        )
    
    # some faces may have no movable vertices.  We can't really allow this, so instead I
    # am going to allow these to move all of their vertices
    orphaned_count = 0
    for face in range(face_count):
        if not np.any(face_updates[face]):
            orphaned_count += 1
            face_updates[face] = [True] * 3
    if orphaned_count > 0:
        print("Warning, found orphaned faces in mesh.")
    
    return np.array(face_updates, dtype=np.bool)
        

# -----------------------------------------------------------------------------------------

def connections_to_array(connection_list, dtype=np.float64, inverse=True):
    """
    Converts a list of sets of indices that encodes the desired connections into a numpy 
    array that can be used to modify the gradient.  The return is a matrix that can be left
    multiplied onto a vector to implement the desired connections upon update.
    """
    size = len(connection_list)
    array = np.array(
        [[1 if j in row else 0 for j in range(size)] for row in connection_list],
        dtype=dtype
    )
    array += np.eye(size, dtype=dtype)
    if inverse:
        return array
    else:
        return array.T

# =========================================================================================

def visualize_connections(plot, mesh, connection_list, color="yellow"):
    """
    Plots lines on a pyvista plot that visualize a directed graph.  The graph is represented
    by connection_list, which has an element for each vertex in the mesh that contains
    a set of other vertexes to be connected to it.
    """
    start_points = []
    end_points = []
    points = mesh.points
    point_count = points.shape[0]

    for i in range(point_count):
        for connection in connection_list[i]:
            start_points.append(points[i])
            end_points.append(points[connection])
    start_points = np.array(start_points)
    end_points = np.array(end_points)
    
    end_points -= start_points
    
    plot.add_arrows(start_points, end_points, color=color)
    
# -----------------------------------------------------------------------------------------

def visualize_generations(
    plot, mesh, generations, colors=["red", "yellow", "green", "blue", "purple"]
):
    """
    Plots points as colored dots that use color to visualize generations.
    """
    
    colors = itertools.cycle(colors)
    for generation in generations:
        color = next(colors)
        points = np.take(mesh.points, list(generation), axis=0)
        plot.add_mesh(
            pv.PolyData(points),
            color=color,
            point_size=10,
            render_points_as_spheres=True
        )

# -----------------------------------------------------------------------------------------
        
def visualize_face_updates(plot, mesh, face_updates, color="red"):
    start_points = []
    end_points = []
    points = mesh.points
    faces = np.reshape(mesh.faces, (-1, 4))[:,1:]
    face_count = faces.shape[0]
    
    for i in range(face_count):
        if np.any(face_updates[i]):
            face = faces[i]
            vertices = np.take(points, face, axis=0)
            center = np.sum(vertices, axis=0)/3
            movable_vertices = vertices[face_updates[i],:]
            for each in movable_vertices:
                start_points.append(center)
                end_points.append(each - center)
    
    start_points = np.array(start_points)
    end_points = np.array(end_points)            
    plot.add_arrows(start_points, end_points, color=color)
            
            
            
    
        
    












