import pytest
import math

import tensorflow as tf
import numpy as np

import tfrt.geometry as geometry

PI = math.pi


def mod2PI(angle, name=None): # moved out of geometry.
    """
    Utility for reducing angles to the range [0, 2PI].
    
    Note that the reduction range includes both zero and 2PI, so this operation isn't
    quite a proper modulo operation.  This operation does not actually perform a
    division, only comparison and addition/subtraction.  It will only change the angle
    by a single multiple of 2PI, so if the angle is greater than 4PI or less than
    -2PI it won't map to the correct range.
    
    Parameters
    ----------
    angle : float tensor-like
        The angle to reduce.
    name : str, optional
        The name of the name scope to use for the operations generated by this
        function.  Defaults to "mod2PI".
        
    Returns
    -------
    A tensor of the same shape and type as angle.
    
    """
    with tf.name_scope(name, default_name="mod2PI"):
        angle = tf.where(angle > 2 * PI, angle - 2 * PI, angle)
        angle = tf.where(angle < 0.0, angle + 2 * PI, angle)
        return angle


def mod_neg2PI(angle, name=None): # moved out of geometry.
    """
    Utility for reducing angles to the range [-2PI, 0].
    
    Note that the reduction range includes both zero and -2PI, so this operation isn't
    quite a proper modulo operation.  This operation does not actually perform a
    division, only comparison and addition/subtraction.  It will only change the angle
    by a single multiple of 2PI, so if the angle is greater than 2PI or less than
    -4PI it won't map to the correct range.
    
    Parameters
    ----------
    angle : float tensor-like
        The angle to reduce.
    name : str, optional
        The name of the name scope to use for the operations generated by this
        function.  Defaults to "mod_neg2PI".
        
    Returns
    -------
    A tensor of the same shape and type as angle.
    
    """
    with tf.name_scope(name, default_name="mod_neg2PI"):
        angle = tf.where(angle > 0.0, angle - 2 * PI, angle)
        angle = tf.where(angle < -2 * PI, angle + 2 * PI, angle)
        return angle

def generate_angles_in_interval(session, start, stop, count, epsilion=1e-10):
    s, e = session.run((tf.mod(start, 2*PI), tf.mod(stop, 2*PI)))
    if abs(s - e) < epsilion:  # full interval
        print(f"full interval: {s} => {e}")
        full_interval = True
    else:
        print(f"partial interval: {s} => {e}")
        full_interval = False

    p_start = mod2PI(start)
    p_stop = mod2PI(stop)
    n_start = mod_neg2PI(start - 2 * PI)
    n_stop = mod_neg2PI(stop)

    if full_interval:
        p_angles = tf.linspace(p_start, p_start + 2 * PI, count)
        n_angles = tf.linspace(n_start, n_start + 2 * PI, count)
    else:
        p_stop = tf.where(tf.less(p_stop, p_start), p_stop + 2 * PI, p_stop)
        p_angles = tf.linspace(p_start, p_stop, count)
        n_stop = tf.where(tf.less(n_stop, n_start), n_stop + 2 * PI, n_stop)
        n_angles = tf.linspace(n_start, n_stop, count)

    p_angles = mod2PI(p_angles)
    n_angles = mod_neg2PI(n_angles)
    return tf.stack((p_angles, n_angles))


def generate_angles_outside_interval(session, start, stop, count, epsilion=1e-10):
    s, e = session.run((tf.mod(start, 2*PI), tf.mod(stop, 2*PI)))
    #s, e = session.run((start, stop))
    #s = s % (2 * PI)
    #e = e % (2 * PI)
    if abs(s - e) < epsilion:  # full interval
        return tf.zeros(0, dtype=tf.float64)
    else:
        return generate_angles_in_interval(session, stop, start, count + 2)[:, 1:-1]


@pytest.mark.parametrize(
    "start",
    [
        0.0,
        0.00001 * PI,
        1 / 4 * PI,
        0.99999 * PI,
        PI,
        1.00001 * PI,
        3 / 4 * PI,
        1.99999 * PI,
        2 * PI,
        -0.00001 * PI,
        -1 / 4 * PI,
        -0.99999 * PI,
        -PI,
        -1.00001 * PI,
        -3 / 4 * PI,
        -1.99999 * PI,
        -2 * PI,
    ],
)
@pytest.mark.parametrize(
    "stop",
    [
        0.0,
        0.00001 * PI,
        1 / 4 * PI,
        0.99999 * PI,
        PI,
        1.00001 * PI,
        3 / 4 * PI,
        1.99999 * PI,
        2 * PI,
        -0.00001 * PI,
        -1 / 4 * PI,
        -0.99999 * PI,
        -PI,
        -1.00001 * PI,
        -3 / 4 * PI,
        -1.99999 * PI,
        -2 * PI,
    ],
)
def test_interval(session, start, stop, count=11):
    print(f"start: {math.degrees(start)}, stop: {math.degrees(stop)}")
    start = tf.cast(start, tf.float64)
    stop = tf.cast(stop, tf.float64)

    included_angles = generate_angles_in_interval(session, start, stop, count)
    excluded_angles = generate_angles_outside_interval(session, start, stop, count)
    is_included = geometry.angle_in_interval(included_angles, start, stop)
    is_excluded = geometry.angle_in_interval(excluded_angles, start, stop)

    print("===================")
    print("included angles:")
    print(np.degrees(session.run(included_angles)))
    print(session.run(is_included))

    print("===================")
    print("excluded angles:")
    print(np.degrees(session.run(excluded_angles)))
    print(session.run(is_excluded))

    all_included = tf.reduce_all(is_included)
    all_excluded = tf.logical_not(tf.reduce_any(is_excluded))

    assert session.run(all_included)
    assert session.run(all_excluded)


with tf.Session() as session:
    test_interval(session, -2*PI, 0)
